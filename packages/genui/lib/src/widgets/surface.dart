// Copyright 2025 The Flutter Authors.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:collection/collection.dart';
import 'package:flutter/material.dart';

import '../interfaces/surface_context.dart';
import '../model/catalog.dart';
import '../model/catalog_item.dart';
import '../model/data_model.dart';
import '../model/ui_models.dart';

import '../primitives/logging.dart';
import '../primitives/simple_items.dart';
import 'fallback_widget.dart';

/// A callback for when a user interacts with a widget.
typedef UiEventCallback = void Function(UiEvent event);

/// A widget that renders a dynamic UI surface generated by the AI.
///
/// This widget connects to a [SurfaceContext] and renders the UI defined by the
/// [SurfaceDefinition] for the bound surface.
class Surface extends StatefulWidget {
  /// Creates a [Surface].
  const Surface({
    super.key,
    required this.surfaceContext,
    this.defaultBuilder,
    this.actionDelegate = const DefaultActionDelegate(),
  });

  /// The context that holds the state of this surface.
  final SurfaceContext surfaceContext;

  /// A builder for the widget to display when the surface has no definition.
  final WidgetBuilder? defaultBuilder;

  /// The delegate that handles UI actions.
  final ActionDelegate actionDelegate;

  @override
  State<Surface> createState() => _SurfaceState();
}

class _SurfaceState extends State<Surface> {
  @override
  Widget build(BuildContext context) {
    genUiLogger.fine(
      'Outer Building surface ${widget.surfaceContext.surfaceId}',
    );
    return ValueListenableBuilder<SurfaceDefinition?>(
      valueListenable: widget.surfaceContext.definition,
      builder: (context, definition, child) {
        genUiLogger.fine('Building surface ${widget.surfaceContext.surfaceId}');
        if (definition == null) {
          genUiLogger.info(
            'Surface ${widget.surfaceContext.surfaceId} has no definition.',
          );
          return widget.defaultBuilder?.call(context) ??
              const SizedBox.shrink();
        }
        // Implicit root is "root".
        const rootId = 'root';
        if (definition.components.isEmpty ||
            !definition.components.containsKey(rootId)) {
          genUiLogger.warning(
            'Surface ${widget.surfaceContext.surfaceId} has no root component.',
          );
          return const SizedBox.shrink();
        }

        final Catalog? catalog = _findCatalogForDefinition(definition);
        if (catalog == null) {
          final error = Exception(
            'Catalog with id "${definition.catalogId}" not found.',
          );
          widget.surfaceContext.reportError(error, StackTrace.current);
          return FallbackWidget(error: error);
        }

        return _buildWidget(
          definition,
          catalog,
          rootId,
          DataContext(
            widget.surfaceContext.dataModel,
            DataPath.root,
            functions: catalog.functions,
          ),
        );
      },
    );
  }

  /// The main recursive build function.
  /// It reads a widget definition and its current state from
  /// `widget.definition`
  /// and constructs the corresponding Flutter widget.
  Widget _buildWidget(
    SurfaceDefinition definition,
    Catalog catalog,
    String widgetId,
    DataContext dataContext,
  ) {
    try {
      Component? data = definition.components[widgetId];
      if (data == null) {
        final error = Exception('Widget with id: $widgetId not found.');
        genUiLogger.severe(error.toString());
        widget.surfaceContext.reportError(error, StackTrace.current);
        return FallbackWidget(error: error);
      }

      final JsonMap widgetData = data.properties;
      genUiLogger.finest('Building widget $widgetId');
      return catalog.buildWidget(
        CatalogItemContext(
          id: widgetId,
          data: widgetData,
          type: data.type,
          buildChild: (String childId, [DataContext? childDataContext]) =>
              _buildWidget(
                definition,
                catalog,
                childId,
                childDataContext ?? dataContext,
              ),
          dispatchEvent: _dispatchEvent,
          buildContext: context,
          dataContext: dataContext,
          getComponent: (String componentId) =>
              definition.components[componentId],
          getCatalogItem: (String type) =>
              catalog.items.firstWhereOrNull((item) => item.name == type),
          surfaceId: widget.surfaceContext.surfaceId,
          reportError: widget.surfaceContext.reportError,
        ),
      );
    } catch (exception, stackTrace) {
      genUiLogger.severe(
        'Error building widget $widgetId',
        exception,
        stackTrace,
      );
      widget.surfaceContext.reportError(exception, stackTrace);
      return FallbackWidget(error: exception, stackTrace: stackTrace);
    }
  }

  void _dispatchEvent(UiEvent event) {
    if (widget.actionDelegate.handleEvent(
      context,
      event,
      widget.surfaceContext,
      _buildWidget,
    )) {
      return;
    }

    // The event comes in without a surfaceId, which we add here.
    final Map<String, Object?> eventMap = {
      ...event.toMap(),
      surfaceIdKey: widget.surfaceContext.surfaceId,
    };
    final UiEvent newEvent = event is UserActionEvent
        ? UserActionEvent.fromMap(eventMap)
        : UiEvent.fromMap(eventMap);
    widget.surfaceContext.handleUiEvent(newEvent);
  }

  Catalog? _findCatalogForDefinition(SurfaceDefinition definition) {
    // The surfaceContext is responsible for resolving the catalog based on
    // the current definition in the registry.
    final Catalog? catalog = widget.surfaceContext.catalog;

    if (catalog == null) {
      genUiLogger.severe(
        'Catalog with id "${definition.catalogId}" not found for surface '
        '"${widget.surfaceContext.surfaceId}". Ensure the catalog is provided '
        'to A2uiMessageProcessor.',
      );
    }
    return catalog;
  }
}

/// A delegate for handling UI actions in [Surface].
///
/// Implement this interface to provide custom handling for specific actions,
/// such as showing modals or navigating.
abstract interface class ActionDelegate {
  /// Handles a [UiEvent].
  ///
  /// Returns `true` if the event was handled, `false` otherwise.
  ///
  /// The [context] is the build context of the [Surface].
  /// The [genUiContext] provides access to the surface state.
  /// The [buildWidget] function allows building widgets from the definition,
  /// useful for rendering content inside modals or dialogs.
  bool handleEvent(
    BuildContext context,
    UiEvent event,
    SurfaceContext genUiContext,
    Widget Function(SurfaceDefinition, Catalog, String, DataContext)
    buildWidget,
  );
}

/// The default action delegate that handles standard actions like 'showModal'.
class DefaultActionDelegate implements ActionDelegate {
  /// Creates a [DefaultActionDelegate].
  const DefaultActionDelegate();

  @override
  bool handleEvent(
    BuildContext context,
    UiEvent event,
    SurfaceContext genUiContext,
    Widget Function(SurfaceDefinition, Catalog, String, DataContext)
    buildWidget,
  ) {
    return false;
  }
}
