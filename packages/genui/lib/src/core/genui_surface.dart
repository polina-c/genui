// Copyright 2025 The Flutter Authors.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:collection/collection.dart';
import 'package:flutter/material.dart';

import '../model/catalog.dart';
import '../model/catalog_item.dart';
import '../model/data_model.dart';
import '../model/ui_models.dart';
import '../primitives/constants.dart';
import '../primitives/logging.dart';
import '../primitives/simple_items.dart';
import 'interfaces.dart';

/// A callback for when a user interacts with a widget.
typedef UiEventCallback = void Function(UiEvent event);

/// A widget that renders a dynamic UI surface generated by the AI.
///
/// This widget connects to a [GenUiContext] and renders the UI defined by the
/// [UiDefinition] for the bound surface.
class GenUiSurface extends StatefulWidget {
  /// Creates a [GenUiSurface].
  const GenUiSurface({
    super.key,
    required this.genUiContext,
    this.defaultBuilder,
  });

  /// The context that holds the state of this surface.
  final GenUiContext genUiContext;

  /// A builder for the widget to display when the surface has no definition.
  final WidgetBuilder? defaultBuilder;

  @override
  State<GenUiSurface> createState() => _GenUiSurfaceState();
}

class _GenUiSurfaceState extends State<GenUiSurface> {
  @override
  @override
  Widget build(BuildContext context) {
    genUiLogger.fine('Outer Building surface ${widget.genUiContext.surfaceId}');
    return ValueListenableBuilder<UiDefinition?>(
      valueListenable: widget.genUiContext.definition,
      builder: (context, definition, child) {
        genUiLogger.fine('Building surface ${widget.genUiContext.surfaceId}');
        if (definition == null) {
          genUiLogger.info(
            'Surface ${widget.genUiContext.surfaceId} has no definition.',
          );
          return widget.defaultBuilder?.call(context) ??
              const SizedBox.shrink();
        }
        // Implicit root is "root".
        const rootId = 'root';
        if (definition.components.isEmpty ||
            !definition.components.containsKey(rootId)) {
          genUiLogger.warning(
            'Surface ${widget.genUiContext.surfaceId} has no root component.',
          );
          return const SizedBox.shrink();
        }

        final Catalog? catalog = _findCatalogForDefinition(definition);
        if (catalog == null) {
          return Container();
        }

        return _buildWidget(
          definition,
          catalog,
          rootId,
          DataContext(
            widget.genUiContext.dataModel,
            '/',
          ),
        );
      },
    );
  }

  /// The main recursive build function.
  /// It reads a widget definition and its current state from
  /// `widget.definition`
  /// and constructs the corresponding Flutter widget.
  Widget _buildWidget(
    UiDefinition definition,
    Catalog catalog,
    String widgetId,
    DataContext dataContext,
  ) {
    Component? data = definition.components[widgetId];
    if (data == null) {
      genUiLogger.severe('Widget with id: $widgetId not found.');
      return Placeholder(child: Text('Widget with id: $widgetId not found.'));
    }

    final JsonMap widgetData = data.properties;
    genUiLogger.finest('Building widget $widgetId');
    return catalog.buildWidget(
      CatalogItemContext(
        id: widgetId,
        data: widgetData,
        type: data.type,
        buildChild: (String childId, [DataContext? childDataContext]) =>
            _buildWidget(
              definition,
              catalog,
              childId,
              childDataContext ?? dataContext,
            ),
        dispatchEvent: _dispatchEvent,
        buildContext: context,
        dataContext: dataContext,
        getComponent: (String componentId) =>
            definition.components[componentId],
        surfaceId: widget.genUiContext.surfaceId,
      ),
    );
  }

  void _dispatchEvent(UiEvent event) {
    if (event is UserActionEvent && event.name == 'showModal') {
      final UiDefinition? definition = widget.genUiContext.definition.value;
      if (definition == null) return;

      final Catalog? catalog = _findCatalogForDefinition(definition);
      if (catalog == null) {
        genUiLogger.severe(
          'Cannot show modal for surface "${widget.genUiContext.surfaceId}" '
          'because a catalog was not found.',
        );
        return;
      }

      final modalId = event.context['modalId'] as String;
      final Component? modalComponent = definition.components[modalId];
      if (modalComponent == null) return;
      // The 'contentChild' property is expected to be a direct property of the
      // Modal component.
      final contentChildId =
          modalComponent.properties['contentChild'] as String;
      showModalBottomSheet<void>(
        context: context,
        builder: (context) => _buildWidget(
          definition,
          catalog,
          contentChildId,
          DataContext(
            widget.genUiContext.dataModel,
            '/',
          ),
        ),
      );
      return;
    }

    // The event comes in without a surfaceId, which we add here.
    final Map<String, Object?> eventMap = {
      ...event.toMap(),
      surfaceIdKey: widget.genUiContext.surfaceId,
    };
    final UiEvent newEvent = event is UserActionEvent
        ? UserActionEvent.fromMap(eventMap)
        : UiEvent.fromMap(eventMap);
    widget.genUiContext.handleUiEvent(newEvent);
  }

  Catalog? _findCatalogForDefinition(UiDefinition definition) {
    final String catalogId = definition.catalogId ?? standardCatalogId;
    final Catalog? catalog = widget.genUiContext.catalogs.firstWhereOrNull(
      (c) => c.catalogId == catalogId,
    );

    if (catalog == null) {
      genUiLogger.severe(
        'Catalog with id "$catalogId" not found for surface '
        '"${widget.genUiContext.surfaceId}". Ensure the catalog is provided to '
        'A2uiMessageProcessor.',
      );
    }
    return catalog;
  }
}
